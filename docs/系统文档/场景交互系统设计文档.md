# 场景交互系统设计文档

## 1. 系统概述

本系统是一个纯服务端驱动的、可配置的、事件驱动的通用场景交互框架。其核心目的是让策划或设计师能够通过修改配置文件，轻松地在游戏世界中创建各种交互节点（如跳台、陷阱、治疗区、任务触发器等），而无需修改核心代码。

系统的所有逻辑均在服务端运行，保证了游戏逻辑的安全性和数据一致性，客户端只负责接收指令并执行表现。

## 2. 核心设计思想

系统采用了"**管理器-处理器**"（Manager-Handler）的分层设计模式，并借鉴了实体组件系统（ECS）的思想。

-   **管理器 (Manager)**: `SceneNodeManager` 是整个系统的"总指挥"。它负责解析配置、创建和管理所有节点的生命周期，并将具体的事件分派给对应的处理器。它保持通用性，不包含任何具体玩法逻辑。
-   **处理器 (Handler)**: 每个`Handler`都是一个"专家"，负责处理一种特定类型的场景交互逻辑（如 `JumpPlatformHandler` 只负责处理跳台）。它们继承自统一的基类 `SceneNodeHandlerBase`。
-   **事件驱动**: 整个系统完全由引擎底层的物理事件（`Touched`, `TouchEnded`）驱动，没有常驻的Update轮询（除了Handler内部用于处理定时指令的独立定时器），性能高效。

## 3. 目录结构

所有与本系统相关的代码都位于 `ServerStorage/SceneInteraction/` 目录下，作为一个独立的全局系统存在。

```
ServerStorage/
└── SceneInteraction/
    ├── SceneNodeManager.lua     # 系统的总管理器
    ├── SceneNodeHandlerBase.lua # 所有处理器的基类 (定义接口和通用逻辑)
    └── handlers/                # 存放所有具体处理器实现的文件夹
        ├── JumpPlatformHandler.lua
        └── ... (其他处理器)
```

## 4. 工作流程

### A. 服务器启动阶段

1.  `MServerMain.lua` 在服务器启动时调用 `SceneNodeManager:Init()`。
2.  `SceneNodeManager` 读取 `MainStorage/Code/Common/Config/SceneNodeConfig.lua` 文件。
3.  遍历配置表中的每一个节点条目。
4.  根据配置的 `["场景类型"]` 字段，从内部的 `handlerMap` 映射表中找到对应的处理器类。
5.  根据 `["场景节点路径"]`，使用 `game.Workspace:FindNodeByPath()` 在游戏世界中找到对应的实体 `Model`。
6.  创建一个处理器类的实例，并将实体和该条配置信息传给它。
7.  根据 `["触发器类型"]` (如 "TOUCH" 或 "AREA")，为实体绑定引擎的 `Touched` 和/或 `TouchEnded` 事件，并将回调指向该处理器实例的对应方法 (`OnTouch`, `OnEnter`, `OnLeave`)。
8.  如果节点配置了 `["定时指令列表"]`，则调用处理器的 `StartPeriodicCommands()` 方法，启动一个独立的 `ServerScheduler` 定时器。

### B. 玩家交互阶段 (运行时)

1.  **当玩家触发一个"TOUCH"类型的节点 (如跳台):**
    -   玩家的`Actor`与节点的`Model`发生物理碰撞，引擎触发 `Touched` 事件。
    -   `SceneNodeManager` 绑定的回调被执行，它调用对应 `Handler` 实例的 `OnTouch` 方法。
    -   `Handler` 内部执行具体逻辑（如检查冷却、向客户端发送跳跃指令、执行服务器指令等）。

2.  **当玩家进入一个"AREA"类型的节点:**
    -   玩家的`Actor`首次接触区域的`Model`，`Touched` 事件触发。
    -   `SceneNodeManager` 调用 `Handler` 的 `OnEnter` 方法。
    -   `OnEnter` 方法内部有防抖动逻辑，确认是有效进入后，将玩家存入 `playersInZone` 列表，并执行 `["进入指令"]`。

3.  **当玩家离开一个"AREA"类型的节点:**
    -   玩家的`Actor`结束接触区域的`Model`，`TouchEnded` 事件触发。
    -   `SceneNodeManager` 调用 `Handler` 的 `OnLeave` 方法。
    -   `OnLeave` 方法会启动一个0.1秒的短暂延迟定时器，以防止因网络或物理"抖动"造成的假离开。
    -   延迟结束后，如果玩家确实已离开，则将其从 `playersInZone` 列表中移除，并执行 `["离开指令"]`。

## 5. 如何扩展 (添加一个新的节点类型)

添加一个全新的交互类型（例如"陷阱"）非常简单，只需三步：

1.  **创建新的处理器**:
    -   在 `ServerStorage/SceneInteraction/handlers/` 目录下，创建一个新的 `TrapHandler.lua` 文件。
    -   让它继承自 `SceneNodeHandlerBase`。
    -   重写 `OnTouch` 或 `OnEnter` 等方法，在其中实现陷阱的核心逻辑（如扣血、施加Buff等）。

2.  **注册处理器**:
    -   打开 `ServerStorage/SceneInteraction/SceneNodeManager.lua` 文件。
    -   在顶部的 `handlerMap` 表中，添加一条新记录：
        ```lua
        local handlerMap = {
            ["跳台"] = require(...),
            ["陷阱"] = require(ServerStorage.SceneInteraction.handlers.TrapHandler), -- 新增此行
        }
        ```

3.  **添加配置**:
    -   打开 `SceneNodeConfig.lua` 配置文件。
    -   添加一条新的节点数据，将 `["场景类型"]` 设置为 `"陷阱"`，并配置好该陷阱所需的其他参数。

完成以上三步并重启服务器后，新的陷阱节点即可在游戏中生效，无需改动任何框架代码。 