# AI助手协作指南：如何提出高效的指令

## 前言

本文档旨在通过优化您向AI助手（也就是我）提问的方式，显著提升我们的协作效率。请把我当作一个能力很强、精通多种编程语言和工具，但对本项目的历史和细节一无所知的新同事。

您的角色是**领航员（Navigator）**，负责把控项目架构、设计思路和最终目标。
我的角色是**驾驶员（Driver）**，负责根据您的清晰指令，快速、准确地完成具体的编码和操作任务。

遵循以下模式，您将能最大限度地发挥我的能力，获得更高质量、更符合预期的成果。

---

## 核心原则：从"程序员"思维转变为"项目经理"思维

您需要给我下达的是**带有上下文和明确目标的任务**，而不是仅仅描述一个问题或一个想法。

---

## 高效指令的八大协作模式

### 模式一：目标导向式提问（明确最终目的）

这是最重要、最能提升效率的模式。请直接告诉我您**想要达成什么**，而不仅仅是**遇到了什么问题**。

-   **低效提问（只描述问题）：**
    > "我的客户端玩家会一直跳跃呢？"
    > *（这会让我花费大量时间去猜测问题原因，可能会提出不符合您想法的解决方案，比如增加冷却时间。）*

-   **高效提问（描述问题 + 给出明确目标/修正方向）：**
    > "我的客户端玩家会一直跳跃。我发现 `Actor.Jump(true)` 是一个持续状态，需要调用 `Actor.Jump(false)` 来关闭。**请你在 `ClientMain.lua` 的 `S2C_Player_Jump` 事件监听器中，延迟0.1秒后调用 `Jump(false)`。**"

**效果对比：** 高效提问直接指明了问题的根源（`Jump`是持续状态）和清晰的解决方案，让我可以一步到位，精准地修改代码，完全符合您的意图。

### 模式二：上下文驱动式提问（指明操作地点）

您的项目结构清晰，充分利用这一点可以为我节省大量搜索和定位的时间。

-   **低效提问（信息模糊）：**
    > "我要在客户端加一个事件监听。"

-   **高效提问（提供精准路径）：**
    > "我需要在客户端响应服务端的事件。请你：
    > 1.  在 `scriptFiles/game/MainStorage/Code/Client/ClientMain.lua` 脚本中。
    > 2.  找到 `ClientEventManager.Subscribe` 的代码块。
    > 3.  为我注册一个新的事件监听，事件名为 `S2C_Player_Jump`。"

**效果对比：** 高效提问为我提供了"操作手册"，明确了"在哪里"、"用什么工具"、"做什么事"，让我可以像手术刀一样精确地执行。

### 模式三：API引用式提问（成为我的API老师）

您提供的 `docs/迷你节点api` 文件夹是我们之间最宝贵的知识库。在我误用或虚构API时（如 `GetComponent`, `AutoDestroy`），您总能通过文档发现问题。您可以更主动地用它来指导我。

-   **低效提问（让我猜测API）：**
    > "你还没有设置玩家的速度，跳不起来。"

-   **高效提问（引用文档，指导API用法）：**
    > "我希望玩家能被'发射'出去，而不是原地跳。根据 `docs/迷你节点api/Actor.md` 文档，`SetJumpInfo(baseSpeed, continueSpeed)` 函数可以设置跳跃速度。**请你在 `ClientMain.lua` 的跳跃事件里，先调用 `SetJumpInfo(4, 4)`，再执行 `Jump(true)`。**"

**效果对比：** 高效提问直接教会了我如何使用您项目的专属API，这不仅避免了我犯错，更能确保最终实现的效果100%符合您的预期。

### 模式四：任务分解式提问（将大象装进冰箱）

对于一个复杂的新功能，您可以像架构师一样，先将其分解为多个定义清晰的子任务，然后一步步引导我完成。

-   **低效提问（模糊的大任务）：**
    > "帮我做一个背包系统。"

-   **高效提问（分解后的清晰步骤）：**
    > "我们来一起构建背包系统，今天先完成第一步：数据结构。
    > 1.  请在 `ServerStorage/MSystems/` 下创建新目录 `Bag`。
    > 2.  在 `Bag` 目录下创建 `Item.lua`，定义物品基类，应包含ID、名称、数量等属性。
    > 3.  在 `Bag` 目录下创建 `Bag.lua`，定义背包类，内部用一个table来存储`Item`对象，并提供`AddItem`和`RemoveItem`方法。"

**效果对比：** 直接提出大任务，我可能会做出不符合您项目规范的架构。通过分解任务，您始终掌握着架构设计的主导权，我则能高质量地完成每一个子模块，最终组合成您想要的那个"大象"。

### 模式五：连锁反应调试与系统性思维（引导AI修复深层BUG）

大型项目是复杂的系统，一个地方的改动可能会像多米诺骨牌一样，引发一连串意想不到的错误。当这种情况发生时，您作为领航员，可以通过系统性的引导，帮助我（驾驶员）快速定位并修复问题的根源。

我们在重构 `SceneNodeManager` 时就经历了一次典型的连锁反应。一个看似简单的改动，导致了后续**5个**环环相扣的Bug。以下是我们成功解决这个问题的协作模式：

-   **低效引导（只关注表面错误）：**
    > "又报错了，快修复它。"
    > *（这会让我陷入"打地鼠"式的修复，治标不治本，因为我们没有找到最初的"推倒的骨牌"。）*

-   **高效引导（系统化调试流程）：**

    1.  **提供最初的错误，追溯数据源头：**
        > "重构后，游戏提示 `未在配置中找到'区域节点配置'`。这个错误发生在 `SceneNodeHandlerBase`。这个模块的 `config` data来自 `SceneNodeManager`，**让我们先检查 `SceneNodeManager` 传递的数据格式是否发生了变化。**"

    2.  **检查相关模块，举一反三：**
        > "很好，基类 `SceneNodeHandlerBase` 修复了。但是，它的子类 `RaceTriggerHandler` 可能还在使用旧的方式。**请检查所有继承自 `SceneNodeHandlerBase` 的处理器，确保它们都使用了新的属性访问方式。**"

    3.  **提醒我注意"全局规则"和"隐性约定"：**
        > "现在传送时找不到场景处理器了。我提醒你一下，在我们的架构里，所有处理器在被 `SceneNodeManager` 创建后，都必须**手动注册到 `MServerDataManager` 中才能被全局访问。请检查一下注册逻辑是否缺失。**"

    4.  **挑战代码的"固有假设"：**
        > "现在提示 `未配置有效的复活点`。我们的 `_getNodeFromPath` 函数假设目标节点一定是子节点，但**我怀疑 `respawnNode` 其实是兄弟节点。请修改这个函数，让它在当前节点找不到时，尝试去父节点下查找。**"

**效果对比：** 通过这种系统性的引导，您将我从一个只会修复表面错误的"代码工人"，提升为了一个能理解系统复杂性的"调试伙伴"。我们不再是无头苍蝇一样地修复一个个冒出来的bug，而是像侦探一样，顺着线索，直捣问题的根源。

### 模式六：渐进式精炼指令（避免复杂多重要求）

对于需要多层次优化的任务，不要一次性提出所有要求，而是分阶段进行精炼。这种模式能避免理解偏差，确保每个阶段的结果都精确符合预期。

-   **低效提问（一次性多重要求）：**
    > "移除所有调试日志，但保留错误日志和比赛开始结束日志，同时确保关键状态变化有记录，但不要太频繁。"
    > *（这种复杂指令容易让AI产生理解偏差，可能保留了不该保留的，删除了不该删除的。）*

-   **高效提问（分阶段精炼）：**
    > 第一阶段："去掉那些RaceGameAction和RaceGameMode过渡打印的日志"
    > *（等待AI完成并确认结果）*
    > 第二阶段："现在留下我比赛开始和比赛结束日志即可"

**效果对比：** 分阶段指令让AI专注处理当前任务，在第一阶段结果基础上进行精确调整，最终结果更加精准。每个阶段都可以验证和纠正，避免了返工。

### 模式七：编程原则先行（用价值观指导具体实现）

在项目开始时设定清晰的编程原则，让AI在每次编码时都有一致的指导思想，无需重复提醒。

**推荐做法：**
在用户规则中明确设定项目价值观：
```
- 拒绝过度设计代码 (Reject over-engineering code)  
- Keep it simple (KISS原则)
- 拒绝过度日志打印
- 优先性能，避免不必要的计算
- 统一的代码风格和命名规范
```

**实际效果：**
设定这些原则后，AI会自动：
- 选择简洁的实现方案而非复杂的设计模式
- 控制日志输出，只保留关键信息
- 保持代码风格的一致性
- 在性能和可读性之间做出合理权衡

### 模式八：记忆驱动的一致性（建立项目编码DNA）

通过记忆系统记录重要的编码规范、API使用模式、架构决策，确保整个项目的一致性。

**推荐记录内容：**
- 重要的引用模式（如 MPlayer 的标准写法）
- 项目特有的API使用规范  
- 关键的架构决策和设计模式
- 常见问题的标准解决方案

**使用方式：**
当发现AI重复某种模式或出现规范问题时，主动要求AI创建记忆：
> "请记住：所有 MPlayer 引用都要使用 `MPlayer = require(ServerStorage.EntityTypes.MPlayer)` 模式，并添加 `---@type MPlayer` 注解。"

**长期效果：** 项目越进行，记忆库越丰富，AI的代码质量和一致性会显著提升，减少重复性的规范纠正。

---

## 辅助工具：善用日志和错误信息

您在我们的协作中已经将这一点运用得炉火纯青。向我提供**完整的、未经删改的**错误日志和相关的代码片段，是最高效的问题沟通方式。它能让我立刻定位到出错的文件和行号，是我调试和修复问题的"导航地图"。

---

## 总结

我们之间的协作是一场"结对编程"。您是经验丰富的领航员，负责规划路线、把控方向。我是专注的驾驶员，负责根据您的清晰指令，快速、准确地编写代码。

### 核心协作技巧总结：

1. **目标导向**：告诉AI"要做什么"而不只是"出了什么问题"
2. **上下文明确**：提供精准的文件路径和操作位置
3. **API引导**：用项目文档教会AI正确的用法
4. **任务分解**：将复杂功能拆分为清晰的子任务
5. **系统性调试**：引导AI理解问题的根源和连锁反应
6. **分阶段优化**：复杂任务拆分为多个渐进式指令，每个阶段验证后再进入下一阶段
7. **原则先行**：在项目开始时设定清晰的编程哲学（如KISS原则），让AI形成一致的代码风格
8. **记忆建设**：主动记录重要的编码规范和设计决策，形成项目的"编码DNA"

### 沟通效率提升：
- **简洁沟通**：使用中文进行简洁高效的沟通，避免冗长的英文技术描述
- **完整日志**：提供完整、未删改的错误信息，让AI快速定位问题
- **验证确认**：每个阶段完成后确认结果，避免后续返工

您提供给我**目标明确、上下文清晰、引用充分、步骤具体**的指令，我便能回报您高质量、高效率的编码服务。随着协作的深入，通过记忆积累和原则建立，我们的协作效率将不断提升。 